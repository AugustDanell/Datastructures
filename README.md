# Datastructures
This is a repository where I implement various datastructures as a way of improving both my conceptual understanding of them while at the same time improving upon my Python skills. In this repo I implement among other datastructures the very common ones, Linked Lists, single and double linked, binary search trees, graphs, stacks, queues .. and more datastructures will come, no doubt! :) 

Here follows a list of my current implementations:

- Linked List: A datastructure where a node is defined as holding a reference to another node as well as holding a data value. This datastructure is like a chain where each link connects to another link. Right now there is one thing that can be improved upon, that I realized, and that is the time of insertion in the list. As it is implemented right now we traverse the entire list to get to the last element but this can be improved upon simply by storing the last element like we do with the bottom element, and so insertion can be made in constant time.

- Stack: A Stack is like a pile of dishes where we can only get to the top item. This datastructure is used to facilitate things like Depth First Searches and much more. This stack is implemented using a python list. Insertion is in constant time, basically it works like a normal list but with the exception that we can only pop the very last element, as such, the last element in will be the first element out (LIFO)

- Queue: A Queue is like the opposite of the stack, it works similarily in that we can only pop one element at a time but rather than the element on the top it is the element on the absolute bottum, the element that has been queing the longest. We can think of it conceptually as a queue to a tourist attraction, the people in the front have been standing the longest and when there is room for one more the person who was first in will be first out (FIFO). LIFO vs FIFO, that is stacks vs queues, can be used to implement things such as BFS and DFS. In my graph implementation I implement the DFS and BFS using a generic search function that takes a datastructure to store which neighbors to visit next. If that datastructure is a stack the search becomes DFS and if it is a queue the seach becomes BFS, naturally, as they are each other's opposites. 

- Binary Search Tree: The binary search tree is a datastructure that starts of with a node and from that spans a tree that grows, if you so will, underground. It grows downwards. Every node in that tree has a right node and a left node, and a greater value than the root is stored to the right and a smaller to the left. This way of structuring data can be very fast, say you want to find an element 5, and the root is 2, we can look to the right to then find 8, and from that node we look to the left and maybe we find 5 already. The search traverses to the left and right of nodes, depending on if the searched for value is smaller or greater respectively. In a balanced search tree this is a very clver and efficient way of storing data as we can in worst case scenario find it in O(Log N) time, where the log is in base 2 specifically. However, when the tree is unbalanced, consider for instance the input of a sorted or reversed list, in that case the tree will be unbalanced and we will need to balance it out or it will be just as bad as a normal linked list. 

- Trie: Trie is an interesting datastructure though presumably with a specialized use as compared to many other datastructures. Trie is a tree where every node has a list of children, and in our implementation we map that with a key, so that key can naturally be seen as an edge, if you so will. current_node.children_list[a] = new_node, means that from one node, we can traverse down an edge to a new node. The edges are letters and the nodes form networks of these letters as well as holding a truth value val. If val is set as true that means that the combination of edges down to that specific node is being stored. Say for instance we want the word "Rigged" and we traverse the tree. We can also insert the word "Rig" by setting the third node as being true. The Trie is a very compact datastructure in that way that is also quick, its good for keeping track of words efficiently. 

- Graph: A graph is a datastructure with a network of nodes that are glued together by edges. A graph can be either directed or undirected. Directed means that one can access node2 from an edge emerging from node1, to node2. An undirected graph also makes it so that such a directed edge is symmetric, if one can go from node2 from node 1, one can also go back to node 1, from node 2. A graph is undirected by default as per the default value false for the parameter 'directed' below. One can also set this to be true when creating the graph, making it so the edges are non-symmetric. The datastructure can bind together a network of nodes and make typical graph searches such as DFS and BFS implemented by queues and stacks specifically. Moreover there is a function to see if the graph is of a tree structure, which means a non-cyclical graph where one can traverse from node x to node y in the graph using one specific path to do so.

- Hotdog: The hotdog is a datastructure without any seemingly useful utility as I can see right now, just a funny implementation of an idea. That idea is specifically to be a combination of a stack and a queue that is to have only the middle element being eligble for popping.

// All the best
